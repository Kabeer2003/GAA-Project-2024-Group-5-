[
  {
    "objectID": "Proposal/proposal.html",
    "href": "Proposal/proposal.html",
    "title": "GAA Group 5: Project Introduction",
    "section": "",
    "text": "Our Objective:\nCulinary Crossroads aims to utilize spatial point patterns to enhance exploration of hawker centres in Singapore. Objectives include creating comprehensive maps of hawker centre locations, identifying regions with higher concentrations, and providing individual maps for detailed analysis. Integration of a user-friendly Shiny app allows users to indicate preferred regions for exploration. Additionally, the project categorizes hawker centre food by cuisine types and dietary preferences, enabling personalized food recommendations aligned with user tastes and dietary restrictions. Overall, the objectives seek to provide a tailored and user-friendly platform for discovering culinary delights in Singapore’s vibrant hawker culture.\n\n\nSteps in this Project :\n\nData Collection and Wrangling:\n\nGather geospatial data on hawker centre locations, cuisine types, dietary types in Singapore.\n\nBuilding the functions\n\nModule 1: 1st Order Analysis - Density and Distribution of Hawker Centres\n[Done by: Gerald]\n\nMap Creation: Develop a map displaying all hawker centres in Singapore.\nKDE 1st Order Analysis: Perform Kernel Density Estimation (KDE) to analyze the density and distribution of hawker centres across Singapore.\nRegional Maps: Provide individual maps for each region to further analyze hawker centre distribution.\nShiny App Integration: Integrate a Shiny app allowing users to indicate (input) their preferred region for hawker centre exploration.\n\nModule 2: 2nd Order Analysis - Hawker Centre Proximity\n[Done by: Kabeer]\n\nSpatial Clustering Analysis: Perform spatial clustering analysis to identify clusters of hawker centres based on proximity.\nDistance Calculation: Calculate the distances between hawker centres within each cluster to assess how closely they are grouped together.\nVisualization: Visualize the clustering results on a map to illustrate the spatial distribution and proximity of hawker centres.\nInterpretation: Interpret the clustering patterns to understand the spatial relationships between hawker centres and identify areas with high and low concentrations.\nShiny App Integration: Integrate a Shiny app allowing users to indicate (input) their preferred region for hawker centre exploration.\n\nModule 3: Geographic Accessibility Modeling of Hawker Centres\n[Done by: Aidan]\n\nMRT Station Selection: Allow users to select their preferred MRT station as a reference point for geographic accessibility analysis.\nBuffer Creation: Create buffer zones around the selected MRT station to represent areas of influence or accessibility.\nHawker Centre Identification: Identify hawker centres located within the buffer zones to assess their accessibility from the chosen MRT station.\nDistance Calculation: Calculate the distances between the selected MRT station and nearby hawker centres to quantify accessibility.\nShiny App Integration: Integrate a Shiny app allowing users to indicate (input) their preferred MRT station for hawker centre exploration, and it’s accessibility to nearby hawker centres.\n\n\n\n\n\nBenefits:\n\nThe project offers numerous benefits, including facilitating exploration of Singapore’s diverse hawker culture through user-friendly maps and personalized recommendations. By highlighting regions with higher concentrations of hawker centres and categorizing food options based on cuisine types and dietary preferences, users can easily discover culinary delights tailored to their tastes. The integration of a Shiny app enhances user engagement and interaction, allowing for seamless navigation and exploration of hawker centres. Ultimately, the project promotes cultural exploration, enhances user experience, and fosters a vibrant community of food enthusiasts in Singapore.\n\n\n\nData Sources\nWhere can we find the data ?\n\nOpenStreetMap (OSM): OpenStreetMap is a collaborative project that provides free and editable geospatial data. You can extract data related to restaurant locations, types, and user reviews.\nSingapore Open Data (data.gov.sg): Hawker Centre Locations (kml)\nDBS PayLah: Dataset with the list of stalls in each hawker centre\nGoogle Places API: Google Places API allows you to retrieve information about places, including restaurants. You can obtain details such as place names, addresses, ratings, and reviews.\n\n\n\nTimeline"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GAA Group 5: Culinary Crossroads",
    "section": "",
    "text": "We are from IS415-G1 Group 5 (better known as CulinaryCrossroads).\nOur project uses geospatial analytics to analyze the density, distribution, proximity and accessibility of hawker centres across Singapore, providing users with personalized recommendations and insights into the vibrant culinary landscape of the city-state.\nAs the saying goes “Good Stuff in the Grand Scheme of Life”.\nOur shinyapp can be accessed via this link"
  },
  {
    "objectID": "index.html#is415-g1-gaa-group-5-culinary-crossroads",
    "href": "index.html#is415-g1-gaa-group-5-culinary-crossroads",
    "title": "GAA Group 5: Culinary Crossroads",
    "section": "",
    "text": "We are from IS415-G1 Group 5 (better known as CulinaryCrossroads).\nOur project uses geospatial analytics to analyze the density, distribution, proximity and accessibility of hawker centres across Singapore, providing users with personalized recommendations and insights into the vibrant culinary landscape of the city-state.\nAs the saying goes “Good Stuff in the Grand Scheme of Life”.\nOur shinyapp can be accessed via this link"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "GAA Group 5: About Us",
    "section": "",
    "text": "We would like to extend our profound gratitude to Professor Kam Tin Seong for his unwavering commitment, dilligence, patience, insightful comments, and impeccable insights that have greatly enlightened us during course of this project. ☺️\nIt has been a fun and enlightening time in IS415 G1.\n\n\n\nSpecial Mention: Our Respected and Dedicated Prof\n\n\n\n\n\n\nProf\nPicture\n\n\n\n\nProf Kam Tin Seong\n\n\n\n\n\n\n\nOur Team Members\n\n\nMembers\nPicture\n\n\n\n\nAidan\n\n\n\nKabeer\n\n\n\nGerald"
  },
  {
    "objectID": "about.html#about-us",
    "href": "about.html#about-us",
    "title": "GAA Group 5: About Us",
    "section": "",
    "text": "We would like to extend our profound gratitude to Professor Kam Tin Seong for his unwavering commitment, dilligence, patience, insightful comments, and impeccable insights that have greatly enlightened us during course of this project. ☺️\nIt has been a fun and enlightening time in IS415 G1.\n\n\n\nSpecial Mention: Our Respected and Dedicated Prof\n\n\n\n\n\n\nProf\nPicture\n\n\n\n\nProf Kam Tin Seong\n\n\n\n\n\n\n\nOur Team Members\n\n\nMembers\nPicture\n\n\n\n\nAidan\n\n\n\nKabeer\n\n\n\nGerald"
  },
  {
    "objectID": "Module1/HawkerCentreDistribution.html",
    "href": "Module1/HawkerCentreDistribution.html",
    "title": "Hawker Centre Distribution using 1st Order Spatial Point Patterns Analysis",
    "section": "",
    "text": "Prototyping Modules for Geospatial Analytics Shiny Application involves selecting the “Distribution of Hawker Centres using 1st Order Spatial Point Patterns Analysis” module and completing tasks such as:\n\nEvaluating R packages compatibility\nTesting R codes for expected outputs\nDetermining parameters and outputs for the Shiny application\nSelecting suitable Shiny UI components to expose these parameters."
  },
  {
    "objectID": "Module1/HawkerCentreDistribution.html#objectives",
    "href": "Module1/HawkerCentreDistribution.html#objectives",
    "title": "Hawker Centre Distribution using 1st Order Spatial Point Patterns Analysis",
    "section": "",
    "text": "Prototyping Modules for Geospatial Analytics Shiny Application involves selecting the “Distribution of Hawker Centres using 1st Order Spatial Point Patterns Analysis” module and completing tasks such as:\n\nEvaluating R packages compatibility\nTesting R codes for expected outputs\nDetermining parameters and outputs for the Shiny application\nSelecting suitable Shiny UI components to expose these parameters."
  },
  {
    "objectID": "Module1/HawkerCentreDistribution.html#install-packages",
    "href": "Module1/HawkerCentreDistribution.html#install-packages",
    "title": "Hawker Centre Distribution using 1st Order Spatial Point Patterns Analysis",
    "section": "1 Install Packages",
    "text": "1 Install Packages\nInstalling the required tools for the analysis:\n\nsf: Package for importing, managing, and processing vector-based geospatial data efficiently.\nspatstat: Package for analyzing spatial point pattern data, including spatial statistics and point process modeling.\nraster: Package for working with raster (gridded) spatial data, enabling analysis and visualization of spatial phenomena.\nmaptools: Package providing tools for reading, writing, and manipulating spatial data in various formats, enhancing interoperability between different geospatial data sources.\ntmap: Package for creating thematic maps and visualizations of spatial data, offering an intuitive interface and flexible options for customization\nreadr: R package that provides fast and friendly functions for reading structured text data, including CSV files\n\n\n\nCode\npacman::p_load(maptools, sf, raster, spatstat, tmap, readr)"
  },
  {
    "objectID": "Module1/HawkerCentreDistribution.html#data-import-and-wrangling",
    "href": "Module1/HawkerCentreDistribution.html#data-import-and-wrangling",
    "title": "Hawker Centre Distribution using 1st Order Spatial Point Patterns Analysis",
    "section": "2 Data Import and Wrangling",
    "text": "2 Data Import and Wrangling\nThis is where we import the data and prepare it before analysis.\nLet’s use st_read() of sf package to import these 3 geospatial data sets into R. And we will be using other functions to prepare our data upon importing them.\nThe data sets are:\n\nupdated_hawker_centres: shows the postal code, latitude and longitude of all hawker centres in Singapore\nMP14_SUBZONE_WEB_PL: polygon feature data providing information of URA 2014 Master Plan Planning Subzone boundary data. It is in ESRI shapefile format. This data set was also downloaded from Data.gov.sg.\nCoastalOutline: a polygon feature data showing the national boundary of Singapore. It is provided by SLA and is in ESRI shapefile format.\n\n\n2.1 Import subzone dataset\nWe will use st_read() of sf package to import the MP14_SUBZONE_WEB_PL dataset into R\n\n\nCode\nmpsz_sf &lt;- st_read(dsn = \"data/geospatial\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\glimjw\\GAA-Project-2024-Group-5-\\Module1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nLet’s check mpsz_sf\n\n\nCode\nst_crs(mpsz_sf)\n\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\n\n\nCode\nsaveRDS(mpsz_sf, file = \"data/rds/mpsz.rds\")\n\n\n\n\nCode\nmpsz_sf &lt;- readRDS(\"data/rds/mpsz.rds\")\n\n\nLet’s plot it to take a look\n\n\nCode\ntmap_options(check.and.fix = TRUE)\ntm_shape(mpsz_sf) +   \n  tm_polygons()\n\n\n\n\n\nOk, now we have a map of Singapore, which we will be using to plot the hawker centres in the future steps.\n\n\n2.2 Import hawker centre data\nNext, we will import our updated_hawker_centres into R\n\n\nCode\nhawker_centre_sf &lt;- read_csv(\"data/aspatial/updated_hawker_centres.csv\")\n\n\nLet’s check the sf type for hawker_centre_sf\n\n\nCode\nst_crs(hawker_centre_sf)\n\n\nCoordinate Reference System: NA\n\n\nSince hawker_centre_sf does not have a Coordinate Reference System, that means it is not a spatial dataframe.\nNow, we have to convert hawker_centre_sf to a spatial dataframe using st_as_sf method\n\n\nCode\n# Convert hawker_centre_sf to sf object\nhawker_centre_sf &lt;- st_as_sf(hawker_centre_sf, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)\n\n\nLet’s check again\n\n\nCode\nst_crs(hawker_centre_sf)\n\n\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\n\n\n\n2.3 Import CoastalOutline dataset\nNext, we will import our CoastalOutline into R\n\n\nCode\nsg_sf &lt;- st_read(dsn = \"data/\", \n                layer = \"CostalOutline\")\n\n\nReading layer `CostalOutline' from data source \n  `C:\\glimjw\\GAA-Project-2024-Group-5-\\Module1\\data' using driver `ESRI Shapefile'\nSimple feature collection with 60 features and 4 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2663.926 ymin: 16357.98 xmax: 56047.79 ymax: 50244.03\nProjected CRS: SVY21\n\n\nLet’s check sg_sf\n\n\nCode\nst_crs(sg_sf)\n\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\n\n\nCode\nsaveRDS(sg_sf, file = \"data/rds/sg.rds\")\n\n\n\n\nCode\nsg_sf &lt;- readRDS(\"data/rds/sg.rds\")\n\n\nThe crs information isn’t consistent as hawker_centre_sf is in WGS84, while the ‘sg_sf” and ’mpsz_sf’ are in SVY21\n\n\nCode\ntarget_crs = st_crs(sg_sf)\nhawker_centre_sf &lt;- st_transform(hawker_centre_sf, target_crs)\nst_crs(hawker_centre_sf)\n\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nLet’s plot sg_sf to see how it looks like\n\n\nCode\ntmap_options(check.and.fix = TRUE)\ntm_shape(sg_sf) +   \n  tm_polygons()\n\n\n\n\n\nWe can see that sg_sf includes the outlying islands of Singapore, where there are no hawker centers. Therefore, we will remove those outlying islands from sg_sf dataset.\n\n\nCode\nmain_island_name &lt;- \"SINGAPORE - MAIN ISLAND\"\n\n# Filter out the main island from sg_sf based on the COSTAL_NAM column\nsg_sf &lt;- sg_sf[sg_sf$COSTAL_NAM == main_island_name, ]\n\n\nNow, let’s check sg_sf again.\n\n\nCode\ntmap_options(check.and.fix = TRUE)\ntm_shape(sg_sf) +   \n  tm_polygons()\n\n\n\n\n\nWe have successfully removed the outlying island, and now sg_sf consist of just the mainland. We will have to ensure that mpsz_sf follows the same. So, we will perform a st_intersection for mpsz_sf and sg_sf so that mpsz_sf will only show the mainland of Singapore (which is our focus area of this project).\n\n\nCode\nmpsz_sf &lt;- st_intersection(mpsz_sf, sg_sf)\nst_crs(mpsz_sf)\n\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\n\n\n2.4 Visualise mpsz_sf and hawker_centre_sf datasets\nLet’s plot both mpsz_sf and hawker_centre_sf datasets using tmap to see the hawker centres points on the map\n\n\nCode\ntm_shape(mpsz_sf) +\n  tm_borders() +\n  tm_fill(\"lightgrey\") +\n  tm_layout(title = \"Map of Singapore with Hawker Centres\") +\n# Add the hawker_centre_sf layer\ntm_shape(hawker_centre_sf) +\n  tm_bubbles(size = 0.2, col = \"red\")\n\n\n\n\n\nNow that we can see the hawker centres (represented by red dots) on the map, we will proceed to doing the necessary preparation for our 1st Order Analysis model.\n\n\n2.5 Convert sf data frames to sp’s Spatial class\nWe have to convert our datasets to sp’s spatial class type by using\n\n\nCode\nmpsz &lt;- as_Spatial(mpsz_sf)\nhawker_centre &lt;- as_Spatial(hawker_centre_sf)\n\n\nLet’s take a look at our newly created spatial classes\n\n\nCode\nmpsz\n\n\nclass       : SpatialPolygonsDataFrame \nfeatures    : 314 \nextent      : 2667.538, 51155.87, 21912.97, 50244.03  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +datum=WGS84 +units=m +no_defs \nvariables   : 19\nnames       : OBJECTID, SUBZONE_NO, SUBZONE_N, SUBZONE_C, CA_IND, PLN_AREA_N, PLN_AREA_C,       REGION_N, REGION_C,          INC_CRC, FMEL_UPD_D,     X_ADDR,     Y_ADDR,    SHAPE_Leng,    SHAPE_Area, ... \nmin values  :        1,          1, ADMIRALTY,    AMSZ01,      N, ANG MO KIO,         AM, CENTRAL REGION,       CR, 00F5E30B5C9B7AD8,      16409,  5092.8949, 26137.8735, 871.554887798, 39437.9352703, ... \nmax values  :      323,         17,    YUNNAN,    YSSZ09,      Y,     YISHUN,         YS,    WEST REGION,       WR, FFCCF172717C2EAF,      16409, 49502.4866, 49552.7904, 54928.0938742,  69748298.792, ... \n\n\n\n\nCode\nhawker_centre\n\n\nclass       : SpatialPointsDataFrame \nfeatures    : 157 \nextent      : 12287.78, 45241.87, 27687.24, 48372.26  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +datum=WGS84 +units=m +no_defs \nvariables   : 3\nnames       :                                              Hawker.Centres, Postal.Code.FULL., Postal.Code \nmin values  : 112 BUKIT MERAH MARKET & FOOD CENTRE  112 JALAN BUKIT MERAH,           S048947,       48947 \nmax values  :                     ZION RIVERSIDE FOOD CENT RE  70 ZION RD,           S828629,      828629 \n\n\n\n\n2.6 Convert spatial class to sp type\nAs the spatial classes are created successfully, we will proceed to converting them into sp type. As spatstat requires data to be in ppp object form, we will have to convert our spatial classes into sp type (sp objects) first. So, we will convert our hawker_centre spatial class into sp type.\n\n\nCode\nhawker_centre_sp &lt;- as(hawker_centre, \"SpatialPoints\")\n\n\nLet’s take a look at the hawker_centre_sp and sg_sp\n\n\nCode\nhawker_centre_sp\n\n\nclass       : SpatialPoints \nfeatures    : 157 \nextent      : 12287.78, 45241.87, 27687.24, 48372.26  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +datum=WGS84 +units=m +no_defs \n\n\n\n\n2.7 Convert sp type to ppp type\nAs mentioned earlier, we will have to convert our sp type for hawker_centre_sp to ppp type\n\n\nCode\nhawker_centre_ppp &lt;- as.ppp(hawker_centre_sp)\nhawker_centre_ppp\n\n\nPlanar point pattern: 157 points\nwindow: rectangle = [12287.78, 45241.87] x [27687.24, 48372.26] units\n\n\nLet’s plot the hawker_centre_ppp and visualise it\n\n\nCode\nplot(hawker_centre_ppp)\n\n\n\n\n\n\n\nCode\nclass(mpsz)\n\n\n[1] \"SpatialPolygonsDataFrame\"\nattr(,\"package\")\n[1] \"sp\"\n\n\n\n\n2.8 Create owin object\nWe will create an owin object so that we can ensure our analysis is within Singapore. We will create an owin object using mpsz.\n\n\nCode\nmpsz_owin &lt;- as.owin(as(mpsz, \"SpatialPolygons\"))\nmpsz_owin\n\n\nwindow: polygonal boundary\nenclosing rectangle: [2667.54, 51155.87] x [21912.97, 50244.03] units\n\n\nLet’s plot mpsz_owin and visualise it.\n\n\nCode\nplot(mpsz_owin)\n\n\n\n\n\n\n\n2.9 Combine ppp with owin object\nNow that we have created our hawker_centre_ppp and mpsz_owin objects, we will combine them and to make sure all our points in hawker_centre_ppp are within the mpsz_owin.\n\n\nCode\n# Plot the PPP on the sg_owin window\nhawker_centre_SG_ppp = hawker_centre_ppp[mpsz_owin]\nplot(hawker_centre_SG_ppp)\n\n\n\n\n\nNow, we can see all the hawker centres which are plotted on the Singapore Map in our newly created hawker_centre_SG_ppp."
  },
  {
    "objectID": "Module1/HawkerCentreDistribution.html#first-order-spatial-point-patterns-analysis-1st-order-analysis",
    "href": "Module1/HawkerCentreDistribution.html#first-order-spatial-point-patterns-analysis-1st-order-analysis",
    "title": "Hawker Centre Distribution using 1st Order Spatial Point Patterns Analysis",
    "section": "3 First-order Spatial Point Patterns Analysis (1st Order Analysis)",
    "text": "3 First-order Spatial Point Patterns Analysis (1st Order Analysis)\nThis is where the magic happens.\n\n3.1 Kernel Density Estimation (KDE)\nWe will be computing the KDE of hawker centres in Singapore.\n\n3.1.1 Computing KDE using automatic bandwidth selection method\nWe will convert the range type to km\n\n\nCode\n# Convert the coordinates of hawker_centre_SG_ppp to a suitable CRS using kilometers\nhawker_centre_SG_ppp_km &lt;- rescale(hawker_centre_SG_ppp, 1000, \"km\")\n\n\nLet’s keep kde_hawker_centre_bw_km in our rds for easy reference in the future. So as to save time in the future when we are performing our analysis.\n\n\nCode\nwrite_rds(hawker_centre_SG_ppp_km, \"data/rds/hawker_centre_SG_ppp_km\")\n\n\nRetrieve kde_hawker_centre_bw_km from rds.\n\n\nCode\nhawker_centre_SG_ppp_km &lt;- read_rds(\"data/rds/hawker_centre_SG_ppp_km\")\n\n\nNow, We will use the density() method to get the KDE\n\n\nCode\n# Perform kernel density estimation with the specified bandwidth and kernel\nkde_hawker_centre_bw_km &lt;- density(hawker_centre_SG_ppp_km,\n                                    sigma = bw.diggle,\n                                    edge=TRUE,\n                                    kernel = \"gaussian\") \n\n\nLet’s keep kde_hawker_centre_bw_km in our rds for easy reference in the future. So as to save time in the future when we are performing our analysis.\n\n\nCode\nwrite_rds(kde_hawker_centre_bw_km, \"data/rds/kde_hawker_centre_bw_km\")\n\n\nRetrieve kde_hawker_centre_bw_km from rds.\n\n\nCode\nkde_hawker_centre_bw_km &lt;- read_rds(\"data/rds/kde_hawker_centre_bw_km\")\n\n\nLet’s plot kde_hawker_centre_bw_km and visualise it\n\n\nCode\nplot(kde_hawker_centre_bw_km)\n\n\n\n\n\nAs you can see from the map above, we can see that there is a higher density of hawker centers in the southern region of Singapore, which is in the Central Business District (CBD), followed by the Eastern side (along the East Coast region of Singapore), and the Central region of Singapore. There are other regions in the West and North where we could see a smaller density of hawker centers.\nFirstly,We will zoom into the different kernel types in the next few steps.\nWhen kernel is gaussian type\n\n\nCode\nplot(density(hawker_centre_SG_ppp_km, \n             sigma=bw.ppl, \n             edge=TRUE, \n             kernel=\"gaussian\"), \n     main=\"Gaussian\")\n\n\n\n\n\nWhen kernel is epanechnikov type\n\n\nCode\nplot(density(hawker_centre_SG_ppp_km, \n             sigma=bw.ppl, \n             edge=TRUE, \n             kernel=\"epanechnikov\"), \n     main=\"Epanechnikov\")\n\n\n\n\n\nWhen kernel is quartic type\n\n\nCode\nplot(density(hawker_centre_SG_ppp_km, \n             sigma=bw.ppl, \n             edge=TRUE, \n             kernel=\"quartic\"), \n     main=\"Quartic\")\n\n\n\n\n\nWhen kernel is disc type\n\n\nCode\nplot(density(hawker_centre_SG_ppp_km, \n             sigma=bw.ppl, \n             edge=TRUE, \n             kernel=\"disc\"), \n     main=\"Disc\")\n\n\n\n\n\nPoint to note:\nFor our shiny app, we will allow users to choose their preferred Kernel type and they are:\n\nGaussian kernel:\n\nDensity is highest at the center of each data point.\nDensity gradually decreases as you move away.\nIt’s like a smooth hill around each point.\n\nEpanechnikov kernel:\n\nDensity forms a bowl shape around each data point.\nFocuses more on points close to the center.\nIt’s like a shallow bowl where nearby points matter more.\n\nQuartic kernel:\n\nSimilar to the Epanechnikov, but with a smoother curve.\nStill focused on each data point.\nResembles a rounded mound where nearby points influence density.\n\nDisc kernel:\n\nCreates a circle around each data point.\nAll points within the circle contribute equally to density.\nIt’s like spreading paint around each point with no preference for distance.\n\n\n\n\nCode\n# Identify duplicated points\nduplicated_points &lt;- hawker_centre_SG_ppp_km[duplicated(hawker_centre_SG_ppp_km), ]\n\n# Remove duplicated points\nhawker_centre_SG_ppp_km &lt;- unique(hawker_centre_SG_ppp_km)\n\nsummary(hawker_centre_SG_ppp_km)\n\n\nPlanar point pattern:  156 points\nAverage intensity 0.245214 points per square km\n\nCoordinates are given to 6 decimal places\n\nWindow: polygonal boundary\nsingle connected closed polygon with 5140 vertices\nenclosing rectangle: [2.66393, 51.15587] x [21.73966, 50.24403] km\n                     (48.49 x 28.5 km)\nWindow area = 636.179 square km\nUnit of length: 1 km\nFraction of frame area: 0.46\n\n\n\n\n3.1.2 Computing KDE using manual bandwidth (sigma)\nWe will try to set sigma to 0.6 and 1.2, which represents 600m and 1.2km respectively.\n\n\nCode\nplot(density(hawker_centre_SG_ppp_km, \n             sigma=0.6, \n             edge=TRUE, \n             kernel=\"disc\"), \n     main=\"sigma=0.6\")\n\n\n\n\n\n\n\nCode\nplot(density(hawker_centre_SG_ppp_km, \n             sigma=1.2, \n             edge=TRUE, \n             kernel=\"disc\"), \n     main=\"sigma=0.6\")\n\n\n\n\n\nPoint to note:\nFor our shiny app, we will allow users to choose their preferred sigma (bandwidth):\n\nExample: 0.3, 0.6, 1.2, etc\n\n\n\n\n3.2 Comparing Spatial Point Patterns using KDE\nWe will be exploring the different spatial point patterns of each areas and region using KDE.\n\n3.2.1 Computing KDE of different areas (planning areas)\nWe will check the number of unique planning areas, PLN_AREA_N, in our mpsz_sf.\n\n\nCode\nnum_planning_areas &lt;- length(unique(mpsz$PLN_AREA_N))\nprint(num_planning_areas)\n\n\n[1] 52\n\n\nWe will also look at the list of planning areas\n\n\nCode\nplanning_areas &lt;- unique(mpsz$PLN_AREA_N)\nprint(planning_areas)\n\n\n [1] \"MARINA SOUTH\"            \"OUTRAM\"                 \n [3] \"SINGAPORE RIVER\"         \"BUKIT MERAH\"            \n [5] \"QUEENSTOWN\"              \"MARINA EAST\"            \n [7] \"RIVER VALLEY\"            \"DOWNTOWN CORE\"          \n [9] \"STRAITS VIEW\"            \"MARINE PARADE\"          \n[11] \"MUSEUM\"                  \"ORCHARD\"                \n[13] \"ROCHOR\"                  \"KALLANG\"                \n[15] \"TANGLIN\"                 \"NEWTON\"                 \n[17] \"CLEMENTI\"                \"TUAS\"                   \n[19] \"BEDOK\"                   \"PIONEER\"                \n[21] \"JURONG EAST\"             \"BUKIT TIMAH\"            \n[23] \"NOVENA\"                  \"GEYLANG\"                \n[25] \"BOON LAY\"                \"TOA PAYOH\"              \n[27] \"JURONG WEST\"             \"BUKIT BATOK\"            \n[29] \"SERANGOON\"               \"PAYA LEBAR\"             \n[31] \"BISHAN\"                  \"TAMPINES\"               \n[33] \"HOUGANG\"                 \"BUKIT PANJANG\"          \n[35] \"ANG MO KIO\"              \"CHOA CHU KANG\"          \n[37] \"PASIR RIS\"               \"CHANGI\"                 \n[39] \"SENGKANG\"                \"CHANGI BAY\"             \n[41] \"TENGAH\"                  \"SUNGEI KADUT\"           \n[43] \"PUNGGOL\"                 \"YISHUN\"                 \n[45] \"MANDAI\"                  \"SELETAR\"                \n[47] \"WOODLANDS\"               \"WESTERN WATER CATCHMENT\"\n[49] \"SEMBAWANG\"               \"LIM CHU KANG\"           \n[51] \"SIMPANG\"                 \"CENTRAL WATER CATCHMENT\"\n\n\nNow, we know that there are 55 regions, which the users can choose from in Shiny app.\nLet’s test some of it and visualize it\n\n\nCode\namk = mpsz[mpsz@data$PLN_AREA_N == \"ANG MO KIO\",]\ntm = mpsz[mpsz@data$PLN_AREA_N == \"TAMPINES\",]\ndt = mpsz[mpsz@data$PLN_AREA_N == \"DOWNTOWN CORE\",]\n\n\nLet’s plot and see\n\n\nCode\npar(mfrow=c(2,2))\nplot(amk, main = \"Ang Mo Kio\")\nplot(tm, main = \"Tampines\")\nplot(dt, main = \"Downtown\")\n\n\n\n\n\nWe will convert them into spatialpolygonsdataframe\n\n\nCode\namk_sp = as(amk, \"SpatialPolygons\")\ntm_sp = as(tm, \"SpatialPolygons\")\ndt_sp = as(dt, \"SpatialPolygons\")\n\n\nWe will create the owin object\n\n\nCode\namk_owin = as(amk_sp, \"owin\")\ntm_owin = as(tm_sp, \"owin\")\ndt_owin = as(dt_sp, \"owin\")\n\n\nCombine them with the hawker centre points into a ppp\n\n\nCode\nhawker_centre_amk_ppp = hawker_centre_ppp[amk_owin]\nhawker_centre_tm_ppp = hawker_centre_ppp[tm_owin]\nhawker_centre_dt_ppp = hawker_centre_ppp[dt_owin]\n\n\nWe have to rescale it to the unit of measurement to km\n\n\nCode\nhawker_centre_amk_ppp_km = rescale(hawker_centre_amk_ppp, 1000, \"km\")\nhawker_centre_tm_ppp_km = rescale(hawker_centre_tm_ppp, 1000, \"km\")\nhawker_centre_dt_ppp_km = rescale(hawker_centre_dt_ppp, 1000, \"km\")\n\n\nLet’s plot and see\n\n\nCode\npar(mfrow=c(2,2))\nplot(hawker_centre_amk_ppp_km, main=\"Ang Mo Kio\")\nplot(hawker_centre_tm_ppp_km, main=\"Tampines\")\nplot(hawker_centre_dt_ppp_km, main=\"Downntown\")\n\n\n\n\n\nNow, it is time for the KDE\n\n\nCode\npar(mfrow=c(2,2))\nplot(density(hawker_centre_amk_ppp_km, \n             sigma=0.25, \n             edge=TRUE, \n             kernel=\"gaussian\"),\n     main=\"Ang Mo Kio\")\nplot(density(hawker_centre_tm_ppp_km, \n             sigma=0.25, \n             edge=TRUE, \n             kernel=\"gaussian\"),\n     main=\"Tampines\")\nplot(density(hawker_centre_dt_ppp_km, \n             sigma=0.25, \n             edge=TRUE, \n             kernel=\"gaussian\"),\n     main=\"Downtown\")\n\n\n\n\n\n\n\n3.2.2 Computing KDE of different regions\nWe will check the number of unique planning area (or region), REGION_N, in our mpsz_sf.\n\n\nCode\nnum_regions &lt;- length(unique(mpsz$REGION_N)) \nprint(num_regions)\n\n\n[1] 5\n\n\nWe will also look at the list of planning areas\n\n\nCode\nregions &lt;- unique(mpsz$REGION_N) \nprint(regions)\n\n\n[1] \"CENTRAL REGION\"    \"WEST REGION\"       \"EAST REGION\"      \n[4] \"NORTH-EAST REGION\" \"NORTH REGION\"     \n\n\nNow, we know that there are 55 regions, which the users can choose from in Shiny app.\nLet’s test some of it and visualize it\n\n\nCode\ncentral = mpsz[mpsz@data$REGION_N == \"CENTRAL REGION\",] \neast = mpsz[mpsz@data$REGION_N == \"EAST REGION\",] \nnorth = mpsz[mpsz@data$REGION_N == \"NORTH REGION\",]\n\n\nLet’s plot and see\n\n\nCode\npar(mfrow=c(2,2))\nplot(central, main = \"Central\")\nplot(east, main = \"East\")\nplot(north, main = \"North\")\n\n\n\n\n\nWe will convert them into spatialpolygonsdataframe\n\n\nCode\ncentral_sp = as(central, \"SpatialPolygons\") \neast_sp = as(east, \"SpatialPolygons\") \nnorth_sp = as(north, \"SpatialPolygons\")\n\n\nWe will create the owin object\n\n\nCode\ncentral_owin = as(central_sp, \"owin\") \neast_owin = as(east_sp, \"owin\") \nnorth_owin = as(north_sp, \"owin\")\n\n\nCombine them with the hawker centre points into a ppp\n\n\nCode\nhawker_centre_central_ppp = hawker_centre_ppp[central_owin] \nhawker_centre_east_ppp = hawker_centre_ppp[east_owin] \nhawker_centre_north_ppp = hawker_centre_ppp[north_owin]\n\n\nWe have to rescale it to the unit of measurement to km\n\n\nCode\nhawker_centre_central_ppp_km = rescale(hawker_centre_central_ppp, 1000, \"km\") \nhawker_centre_east_ppp_km = rescale(hawker_centre_east_ppp, 1000, \"km\") \nhawker_centre_north_ppp_km = rescale(hawker_centre_north_ppp, 1000, \"km\")\n\n\nLet’s plot and see\n\n\nCode\npar(mfrow=c(2,2)) \nplot(hawker_centre_central_ppp_km, main=\"Central\") \nplot(hawker_centre_east_ppp_km, main=\"East\") \nplot(hawker_centre_north_ppp_km, main=\"North\")\n\n\n\n\n\nNow, it is time for the KDE\n\n\nCode\npar(mfrow=c(2,2))\nplot(density(hawker_centre_central_ppp_km, \n             sigma=0.25, \n             edge=TRUE, \n             kernel=\"gaussian\"),\n     main=\"Central\")\nplot(density(hawker_centre_east_ppp_km, \n             sigma=0.25, \n             edge=TRUE, \n             kernel=\"gaussian\"),\n     main=\"East\")\nplot(density(hawker_centre_north_ppp_km, \n             sigma=0.25, \n             edge=TRUE, \n             kernel=\"gaussian\"),\n     main=\"North\")\n\n\n\n\n\nWe can see that there is a higher density of hawker centres in the Central region."
  },
  {
    "objectID": "Module1/HawkerCentreDistribution.html#shiny-app-parameters",
    "href": "Module1/HawkerCentreDistribution.html#shiny-app-parameters",
    "title": "Hawker Centre Distribution using 1st Order Spatial Point Patterns Analysis",
    "section": "4 Shiny App Parameters",
    "text": "4 Shiny App Parameters\n\n4.1 Parameters that will be used\nIn our shiny app, we will allow our users to select the different regions, of which they could do the comparison on their own.\nThese will be the parameters for our shiny app.\nIN SUMMARY for our Shiny App, we will allow our users to provide input for:\n\nSigma (or bandwidth): Users can enter their preferred bandwidth (on a scale)\nKernel: Users can choose the type of kernel type (e.g. Gaussian, Epanechnikov, Quartic, Disc)\nLocation: Users can choose a specific location (planning area) that they would wish to analyse (e.g. Ang Mo Kio, Downtown)\nRegion: Users can choose a specific region that they would wish to analyse (e.g. NORTH, EAST, NORTH-EAST, CENTRAL, WEST)\n\nNote: Region and Location are different. However, we would look into the possibility of allow users to filter region (without choosing a Location), and also allowing them to choose a location through a region should they wish to analyse a specific location.\n\n\n4.2 Module Prototype on shinyapp\nThe shinyapp for this module is completed and it can be accessed via this link\n\n\n4.3 Project Prototype on shinyapp\nThe shinyapp for this collaborative project (including all modules) can be accessed via this link"
  },
  {
    "objectID": "Poster/poster.html",
    "href": "Poster/poster.html",
    "title": "GAA Group 5: Project Poster",
    "section": "",
    "text": "Our Poster"
  }
]